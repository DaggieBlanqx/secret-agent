(window.webpackJsonp=window.webpackJsonp||[]).push([[38],{695:function(e,t,o){"use strict";t.a={name:"VueRemarkRoot",render:function(e){return e("div",null,this.$slots.default)}}},836:function(e,t,o){"use strict";o.r(t);var a=o(1),n=o(695),r=o(0);function i(e){return(i="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}r.a.config.optionMergeStrategies;var s={VueRemarkRoot:n.a},c=function(e){var t=e.options.components=e.options.components||{},o=e.options.computed=e.options.computed||{};Object.keys(s).forEach((function(e){"object"===i(s[e])&&"function"==typeof s[e].render?t[e]=s[e]:o[e]=function(){return s[e]}}))},f=r.a.config.optionMergeStrategies,u="__vueRemarkFrontMatter",d={excerpt:null,title:"OffscreenCanvas"};var p=function(e){e.options[u]&&(e.options[u]=d),r.a.util.defineReactive(e.options,u,d),e.options.computed=f.computed({$frontmatter:function(){return e.options[u]}},e.options.computed)},v=Object(a.a)({},(function(){var e=this,t=e.$createElement,o=e._self._c||t;return o("VueRemarkRoot",[o("h1",{attrs:{id:"offscreencanvas"}},[o("a",{attrs:{href:"#offscreencanvas","aria-hidden":"true"}},[e._v("#")]),e._v("OffscreenCanvas")]),o("div",{staticClass:"overview"},[o("strong",[e._v("This is an "),o("a",{attrs:{href:"/en-US/docs/MDN/Contribute/Guidelines/Conventions_definitions#Experimental"}},[e._v("experimental technology")])]),o("br"),e._v("Check the "),o("a",{attrs:{href:"#Browser_compatibility"}},[e._v("Browser compatibility table")]),e._v(" carefully before using this in production.")]),o("h2",{attrs:{id:"properties"}},[o("a",{attrs:{href:"#properties","aria-hidden":"true"}},[e._v("#")]),e._v("Properties")]),o("ul",{staticClass:"items properties"},[o("li",[o("a",{attrs:{href:""}},[e._v("height")]),o("div",[e._v("The height of the offscreen canvas.")])]),o("li",[o("a",{attrs:{href:""}},[e._v("width")]),o("div",[e._v("The width of the offscreen canvas.")])])]),o("h2",{attrs:{id:"methods"}},[o("a",{attrs:{href:"#methods","aria-hidden":"true"}},[e._v("#")]),e._v("Methods")]),o("ul",{staticClass:"items methods"},[o("li",[o("a",{attrs:{href:""}},[e._v("convertToBlob()")]),o("div",[e._v("Creates a "),o("a",{attrs:{href:"/en-US/docs/Web/API/Blob",title:"A Blob object represents a file-like object of immutable, raw data; they can be read as text or binary data, or converted into a ReadableStream so its methods can be used for processing the data. Blobs can represent data that isn't necessarily in a JavaScript-native format. The File interface is based on Blob, inheriting blob functionality and expanding it to support files on the user's system."}},[o("code",[e._v("Blob")])]),e._v(" object representing the image contained in the canvas.")])]),o("li",[o("a",{attrs:{href:""}},[e._v("getContext()")]),o("div",[e._v("Returns a rendering context for the offscreen canvas.")])]),o("li",[o("a",{attrs:{href:""}},[e._v("transferToImageBitmap()")]),o("div",[e._v("Creates an "),o("a",{attrs:{href:"/en-US/docs/Web/API/ImageBitmap",title:"The ImageBitmap interface represents a bitmap image which can be drawn to a <canvas> without undue latency. It can be created from a variety of source objects using the createImageBitmap() factory method. ImageBitmap provides an asynchronous and resource efficient pathway to prepare textures for rendering in WebGL."}},[o("code",[e._v("ImageBitmap")])]),e._v(" object from the most recently rendered image of the "),o("code",[e._v("OffscreenCanvas")]),e._v(".")])])]),o("h2",{attrs:{id:"events"}},[o("a",{attrs:{href:"#events","aria-hidden":"true"}},[e._v("#")]),e._v("Events")])])}),[],!1,null,null,null);"function"==typeof c&&c(v),"function"==typeof p&&p(v);t.default=v.exports}}]);